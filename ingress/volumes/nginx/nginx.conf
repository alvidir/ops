lua_package_path "/etc/lua-resty-openssl/lib/?.lua;/etc/lua-resty-hmac/lib/?.lua;/etc/lua-resty-jwt/lib/?.lua;;";

server {
    error_log /var/log/nginx/error.log info;

    location / {
        resolver 10.88.5.1; # look at /etc/resolv.conf

        set $proxy "";
        set $subject "";
        rewrite_by_lua_block {
            local private_uri_regex = os.getenv("PROXY_PRIVATE_URI")
            if not ngx.re.match(ngx.var.http_host, private_uri_regex) then
                ngx.var.proxy = os.getenv("PROXY_PASS_PUBLIC")
                return
            end

            local redirect = os.getenv("PROXY_REDIRECT")
            local jwt_header = os.getenv("JWT_HEADER")
            if jwt_header == nil then
                jwt_header = "authorization"
            end 

            local jwt_token = ngx.req.get_headers()[jwt_header]
            if jwt_token == nil then
                return ngx.redirect(redirect)
            end

            local b64 = require("ngx.base64")
            local jwt_token, err = b64.decode_base64url(jwt_token)
            if not jwt_token then
                ngx.log(ngx.WARN, 'could not decode token: ', err)
                return ngx.redirect(redirect)
            end
            
            local jwt_public = os.getenv("JWT_PUBLIC")
            local jwt_public, err = b64.decode_base64url(jwt_public)
            if not jwt_public then
                ngx.log(ngx.WARN, 'could not decode public key: ', err)
                return ngx.redirect(redirect)
            end

            local jwt = require "resty.jwt"
            local claims = jwt:verify(jwt_public, jwt_token)

            local verified = claims['verified']
            if not verified then
                local reason = claims['reason']
                ngx.log(ngx.WARN, 'unverified token: ', reason)
                return ngx.redirect(redirect)
            end

            local payload = claims['payload']
            if payload == nil then 
                ngx.log(ngx.WARN, 'invalid token: no payload found')
                return ngx.redirect(redirect)
            end

            local jti = payload['jti']
            if jti == nil then 
                ngx.log(ngx.WARN, 'invalid token: no token id (jti) in payload')
                return ngx.redirect(redirect)
            end

            ngx.var.subject = payload['sub']
            if ngx.var.subject == nil then 
                ngx.log(ngx.WARN, 'invalid token: no subject in payload')
                return ngx.redirect(redirect)
            end

            local redis = require "resty.redis"
            local red = redis:new()

            red:set_timeouts(1000, 1000, 1000)
            local redis_hostname = os.getenv("REDIS_HOSTNAME")
            local ok, err = red:connect(redis_hostname, 6379)
            if not ok then
                ngx.log(ngx.ERR, 'failed to connect to redis cluster: ', err)
                return ngx.redirect(redirect)
            end

            local res, err = red:get(jti)
            if not res then
                ngx.log(ngx.ERR, "failed to get token with id ", jti, ": ", err)
                return ngx.redirect(redirect)
            end

            if res == ngx.null then
                ngx.log(ngx.WARN, "token with id ", jti, ": not found")
                return ngx.redirect(redirect)
            end

            ngx.var.proxy = os.getenv("PROXY_PASS_PRIVATE")

            local ok, err = red:set_keepalive(10000, 100)
            if not ok then
                ngx.log(ngx.ERR, 'failed to set keepalive: ', err)
                return
            end
        }

        proxy_set_header UserID $subject;
        proxy_pass http://$proxy$uri;
    }
}